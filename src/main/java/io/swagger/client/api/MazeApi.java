/*
 * A-maze-ing API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import com.google.gson.reflect.TypeToken;
import io.swagger.client.*;
import io.swagger.client.model.PossibleActionsAndCurrentScore;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MazeApi {
    private ApiClient apiClient;

    public MazeApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MazeApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for collectScore
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call collectScoreCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/collectScore";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call collectScoreValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = collectScoreCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * üí∞ Collect score from your hand to your bag.
     * Remember that when you exit a maze, only score in your bag will carry over and be awarded to your overall player score. Any score left in your hand will be lost.
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore collectScore() throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = collectScoreWithHttpInfo();
        return resp.getData();
    }

    /**
     * üí∞ Collect score from your hand to your bag.
     * Remember that when you exit a maze, only score in your bag will carry over and be awarded to your overall player score. Any score left in your hand will be lost.
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> collectScoreWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = collectScoreValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * üí∞ Collect score from your hand to your bag. (asynchronously)
     * Remember that when you exit a maze, only score in your bag will carry over and be awarded to your overall player score. Any score left in your hand will be lost.
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call collectScoreAsync(final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = collectScoreValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for enter
     * @param mazeName What maze do you wish to enter. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call enterCall(String mazeName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/enter";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (mazeName != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("mazeName", mazeName));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call enterValidateBeforeCall(String mazeName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = enterCall(mazeName, progressListener, progressRequestListener);
        return call;

    }

    /**
     * üåü Enter a maze.
     * Keep in mind that you can only be playing one maze at a time. Invoking this method when you are already in a maze will result in a failure. Also, you can only play the same maze once. If you wish to play the same maze \&quot;multiple times\&quot;, you need to request to forget your player data (via the player API).
     * @param mazeName What maze do you wish to enter. (optional)
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore enter(String mazeName) throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = enterWithHttpInfo(mazeName);
        return resp.getData();
    }

    /**
     * üåü Enter a maze.
     * Keep in mind that you can only be playing one maze at a time. Invoking this method when you are already in a maze will result in a failure. Also, you can only play the same maze once. If you wish to play the same maze \&quot;multiple times\&quot;, you need to request to forget your player data (via the player API).
     * @param mazeName What maze do you wish to enter. (optional)
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> enterWithHttpInfo(String mazeName) throws ApiException {
        com.squareup.okhttp.Call call = enterValidateBeforeCall(mazeName, null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * üåü Enter a maze. (asynchronously)
     * Keep in mind that you can only be playing one maze at a time. Invoking this method when you are already in a maze will result in a failure. Also, you can only play the same maze once. If you wish to play the same maze \&quot;multiple times\&quot;, you need to request to forget your player data (via the player API).
     * @param mazeName What maze do you wish to enter. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call enterAsync(String mazeName, final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = enterValidateBeforeCall(mazeName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for exitMaze
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call exitMazeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/exit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {

        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call exitMazeValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = exitMazeCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * üö™ Exit the maze.
     * Remember that when you exit a maze, only score in your bag will carry over and be awarded to your overall player score. Any score left in your hand will be lost.   Also, remember that you can only play the same maze once, so make sure you have collected as much score as you can.
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void exitMaze() throws ApiException {
        exitMazeWithHttpInfo();
    }

    /**
     * üö™ Exit the maze.
     * Remember that when you exit a maze, only score in your bag will carry over and be awarded to your overall player score. Any score left in your hand will be lost.   Also, remember that you can only play the same maze once, so make sure you have collected as much score as you can.
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> exitMazeWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = exitMazeValidateBeforeCall(null, null);
        return apiClient.execute(call);
    }

    /**
     * üö™ Exit the maze. (asynchronously)
     * Remember that when you exit a maze, only score in your bag will carry over and be awarded to your overall player score. Any score left in your hand will be lost.   Also, remember that you can only play the same maze once, so make sure you have collected as much score as you can.
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call exitMazeAsync(final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = exitMazeValidateBeforeCall(progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for moveDown
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call moveDownCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/move/down";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call moveDownValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = moveDownCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * ‚¨á Move down.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore moveDown() throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = moveDownWithHttpInfo();
        return resp.getData();
    }

    /**
     * ‚¨á Move down.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> moveDownWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = moveDownValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * ‚¨á Move down. (asynchronously)
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call moveDownAsync(final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = moveDownValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for moveLeft
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call moveLeftCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/move/left";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call moveLeftValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = moveLeftCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * ‚¨Ö Move left.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore moveLeft() throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = moveLeftWithHttpInfo();
        return resp.getData();
    }

    /**
     * ‚¨Ö Move left.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> moveLeftWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = moveLeftValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * ‚¨Ö Move left. (asynchronously)
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call moveLeftAsync(final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = moveLeftValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for moveRight
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call moveRightCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/move/right";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call moveRightValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = moveRightCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * ‚û° Move right.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore moveRight() throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = moveRightWithHttpInfo();
        return resp.getData();
    }

    /**
     * ‚û° Move right.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> moveRightWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = moveRightValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * ‚û° Move right. (asynchronously)
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call moveRightAsync(final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = moveRightValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for moveUp
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call moveUpCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/move/up";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call moveUpValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = moveUpCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * ‚¨Ü Move up.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore moveUp() throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = moveUpWithHttpInfo();
        return resp.getData();
    }

    /**
     * ‚¨Ü Move up.
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> moveUpWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = moveUpValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * ‚¨Ü Move up. (asynchronously)
     * You must have already entered a maze. This method will return 200 even if you could not move in this direction. If there is a \&quot;wall\&quot; in your way and you try to move there.. well, it&#39;s gonna hurt, but you will remain in the same place.. which.. technically.. is valid.. ü§∑üèª‚Äç
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call moveUpAsync(final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = moveUpValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for possibleActions
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call possibleActionsCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/maze/possibleActions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain", "application/json", "text/json", "application/xml", "text/xml"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "User token" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call possibleActionsValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = possibleActionsCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * üëÄ Get the list of possible actions, from the tile where you are standing.
     * You must have already entered a maze. Also, you shouldn&#39;t require this method that much, given than any action you perform on the maze will return this same information.
     * @return PossibleActionsAndCurrentScore
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PossibleActionsAndCurrentScore possibleActions() throws ApiException {
        ApiResponse<PossibleActionsAndCurrentScore> resp = possibleActionsWithHttpInfo();
        return resp.getData();
    }

    /**
     * üëÄ Get the list of possible actions, from the tile where you are standing.
     * You must have already entered a maze. Also, you shouldn&#39;t require this method that much, given than any action you perform on the maze will return this same information.
     * @return ApiResponse&lt;PossibleActionsAndCurrentScore&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PossibleActionsAndCurrentScore> possibleActionsWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = possibleActionsValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * üëÄ Get the list of possible actions, from the tile where you are standing. (asynchronously)
     * You must have already entered a maze. Also, you shouldn&#39;t require this method that much, given than any action you perform on the maze will return this same information.
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call possibleActionsAsync(final ApiCallback<PossibleActionsAndCurrentScore> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = possibleActionsValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<PossibleActionsAndCurrentScore>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
